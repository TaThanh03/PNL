=============================Ex1==================================

Question 1: 

make nconfig -> Kernel hacking -> KGDB: kernel debugger 


Question 2: 

Moyen de communication: TCP client-server, port 1234


Question 3, 5, 6:

1. start VM
2. dans machine hôte, /linux-4.9.86 "gdb vmlinux"
3. dans machine hôte, démarrer GDB, tapper "target remote :1234" -> démarrer le client GDB
4. dans VM, "echo g > /proc/sysrq-trigger" -> démarrer le serveur KGDB
5. ping-pong entre client GDB et server KGDB avec les commands "continue" et "echo g > /proc/sysrq-trigger"


Question 4:

monitor ps est de plus haut niveau, donnant des informations comme pid, ppid, la commande utilisée. Orienté processus.
Info thread se focalise sur les threads. 

=============================Ex2==================================

Question 1: 

Variable init_uts_ns est initialisée dans /init/version.c
Elle contient des champs suivants: sysname, nodename, release, version, machine, domainname


Question 2:

(gdb) print init_uts_ns

$1 = {kref = {refcount = {counter = 4}}, name = {
    sysname = "Linux", '\000' <repeats 59 times>, 
    nodename = "pnl-tp", '\000' <repeats 58 times>, 
    release = "4.9.86", '\000' <repeats 58 times>, 
    version = "#2 SMP Thu Mar 8 17:36:55 CET 2018", '\000' <repeats 30 times>, machine = "x86_64", '\000' <repeats 58 times>, 
    domainname = "(none)", '\000' <repeats 58 times>}, 
  user_ns = 0xffffffff8225cc40 <init_user_ns>, 
  ucounts = 0x0 <irq_stack_union>, ns = {stashed = {counter = 0}, 
    ops = 0xffffffff81c30c00 <utsns_operations>, inum = 4026531838}}

(gdb) set variable init_uts_ns.name.sysname = "BLABLA"

(gdb) print init_uts_ns

$2 = {kref = {refcount = {counter = 4}}, name = {
    sysname = "BLABLA", '\000' <repeats 58 times>, 
    nodename = "pnl-tp", '\000' <repeats 58 times>, 
    release = "4.9.86", '\000' <repeats 58 times>, 
    version = "#2 SMP Thu Mar 8 17:36:55 CET 2018", '\000' <repeats 30 times>, machine = "x86_64", '\000' <repeats 58 times>, 
    domainname = "(none)", '\000' <repeats 58 times>}, 
  user_ns = 0xffffffff8225cc40 <init_user_ns>, 
  ucounts = 0x0 <irq_stack_union>, ns = {stashed = {counter = 0}, 
    ops = 0xffffffff81c30c00 <utsns_operations>, inum = 4026531838}}

=============================Ex3==================================

Question 1:

/**
 * kthread_run - create and wake a thread.
 * @threadfn: the function to run until signal_pending(current).
 * @data: data ptr for @threadfn.
 * @namefmt: printf-style name for the thread.
 *
 * Description: Convenient wrapper for kthread_create() followed by
 * wake_up_process().  Returns the kthread or ERR_PTR(-ENOMEM).
 */
/**
 * my_hanging_fn - set current state of the thread to TASK_UNINTERRUPTIBLE
 */
/**
 * schedule_timeout - sleep until timeout 
 * TASK_UNINTERRUPTIBLE - at least timeout jiffies are guaranteed to
 * pass before the routine returns. The routine will return 0
 */
https://stackoverflow.com/questions/223644/what-is-an-uninterruptable-process
TASK_UNINTERRUPTIBLE, the uninterruptible sleep. If a task is marked with this flag, it is not expecting to be woken up by anything other than whatever it is waiting for, either because it cannot easily be restarted, or because programs are expecting the system call to be atomic. This can also be used for sleeps known to be very short.


Question 2:

La thread de module devrait être bloquée pendant une minute.

La tâche crashe.
INFO: task my_hanging_fn:329 blocked for more than 30 seconds.
Explication: la tâche devient non-interruptible et jamais reveillée.


Question 3: 

make nconfig -> Kernel hacking -> Debug Lockups and Hangs -> Panic (Reboot On Hung Tasks


Question 4:

// copier le résultat de backtrace

Question 5:

// copier le résultat de monitor ps

// copier le résultat de monitor btp


Question 6:

Seconde addresse correspond au lieu où le module est chargé.


Question 7:

La solution qui ne modifie que le module:
set_current_state(TASK_INTERRUPTIBLE);

=============================Ex4==================================

Question 1:

Il y a la liste des timers &prdebug_timer. Son champ data = kstat_cpu(0).irqs_sum. 0 car il s'agit de processeur numéro 0. irqs_sum est le nombre de irqs depuis le début. On y supprime le nombre précédent pour avoir la valeur exacte pendant le dernier créneau.

Rien n'est affiché parce que DDEBUG n'est pas activé. Il faut ajouter la ligne suivante dans le Makefile :

CFLAGS_prdebug.o := -DDEBUG

Question 2:

echo -n 'module prdebug +p' > /sys/kernel/debug/dynamic_debug/control

Le fichier de control est modifié. +p veut dire qu'on veut activer tous les messages du module dont le nom suit "module", dans ce cas prdebug.

Question 3:

echo -n 'module prdebug +pmfl' > /sys/kernel/debug/dynamic_debug/control

Question 4:

echo -n 'module prdebug line 13 +pmfl' > /sys/kernel/debug/dynamic_debug/control

=============================Ex5==================================

Question 1:
 
Un nouveau thread est créé. Il va s'occuper d'afficher, tous les 10 sezcondes, le status du CPU qui est sauvegardé dans le struct my_kcpustat.

Question 2:

Le module crashe.

Question 3:

add-symbol-file ../PNL-master/tp5/EXO-05/kcpustat.o xffffffffa0000000
(le chemin au fichier et la deuxième adresse donnée par la commande monitor lsmod)

echo -n 'module kcpustat +pmfl' > /sys/kernel/debug/dynamic_debug/control

Ex5
add-symbol-file ../PNL-master/tp5/EXO-05/kcpustat.o 0xffffffffa0000000


